import os
from scipy import misc
import matplotlib.pyplot as plt
import numpy as np
import math

def bresenhamLine2(startPoint, endPoint, image):
    WIDTH = len(image[0]) - 1
    HEIGHT = len(image) - 1
    y0, x0 = start_point
    y1, x1 = end_point
    "Bresenham's line algorithm"
    result = 0
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    x, y = x0, y0
    sx = -1 if x0 > x1 else 1
    sy = -1 if y0 > y1 else 1
    if dx > dy:
        err = dx / 2.0
        while x != x1:
            if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
                result += image[y][x]
            err -= dy
            if err < 0:
                y += sy
                err += dx
            x += sx
    else:
        err = dy / 2.0
        while y != y1:
            if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
                result += image[y][x]
            err -= dx
            if err < 0:
                x += sx
                err += dy
            y += sy
    if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
        result += image[y][x]
    return int(result)

def backwardBresenham(startPoint, endPoint, image, value):
    WIDTH = len(image[0]) - 1
    HEIGHT = len(image) - 1
    y0, x0 = startPoint
    y1, x1 = endPoint
    "Bresenham's line algorithm"
    result = 0
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    x, y = x0, y0
    sx = -1 if x0 > x1 else 1
    sy = -1 if y0 > y1 else 1
    if dx > dy:
        err = dx / 2.0
        while x != x1:                                                  #not(math.fabs(x - HEIGHT * 0.5) < 0.1 * HEIGHT and math.fabs(y - WIDTH * 0.5) < WIDTH * 0.1) problem with central points (too bright)
            if 0 <= x <= WIDTH and 0 <= y <= HEIGHT and not(math.fabs(x - HEIGHT * 0.5) < 0.05 * HEIGHT and math.fabs(y - WIDTH * 0.5) < WIDTH * 0.05):
                image[y][x] += value
            err -= dy
            if err < 0:
                y += sy
                err += dx
            x += sx
    else:
        err = dy / 2.0
        while y != y1:
            if 0 <= x <= WIDTH and 0 <= y <= HEIGHT and not(math.fabs(x - HEIGHT * 0.5) < 0.05 * HEIGHT and math.fabs(y - WIDTH * 0.5) < WIDTH * 0.05):
                image[y][x] += value
            err -= dx
            if err < 0:
                x += sx
                err += dy
            y += sy
    if 0 <= x <= WIDTH and 0 <= y <= HEIGHT and not(math.fabs(x - HEIGHT * 0.5) < 0.05 * HEIGHT and math.fabs(y - WIDTH * 0.5) < WIDTH*0.05):
        image[y][x] += value
    return image

def bresenhamLine(start_point, end_point, image):
    WIDTH = len(image[0])-1
    HEIGHT = len(image)-1

    y1, x1 = start_point
    y2, x2 = end_point
    # zmienne pomocnicze
    d, dx, dy, ai, bi, xi, yi = 0, 0, 0, 0, 0, 0, 0
    x, y = x1, y1
    result = 0
    # ustalenie kierunku rysowania
    if (x1 < x2):
        xi = 1
        dx = x2 - x1
    else:
        xi = -1
        dx = x1 - x2

    # ustalenie kierunku rysowania
    if (y1 < y2):
        yi = 1
        dy = y2 - y1

    else:
        yi = -1
        dy = y1 - y2

    # pierwszy piksel
    if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
        result += image[y][x]
    # oś wiodąca OX
    if (dx > dy):
        ai = (dy - dx) * 2
        bi = dy * 2
        d = bi - dx
        # pętla po kolejnych x
        while (x != x2):
            # test współczynnika
            if (d >= 0):
                x += xi
                y += yi
                d += ai

            else:
                d += bi
                x += xi
                if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
                    result += image[y][x]
                    # oś wiodąca OY
    else:
        ai = (dx - dy) * 2
        bi = dx * 2
        d = bi - dy
        # pętla po kolejnych y
        while (y != y2):
            # test współczynnika
            if (d >= 0):
                x += xi
                y += yi
                d += ai
            else:
                d += bi
                y += yi
                if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
                    result += image[y][x]
    return int(result)


STEP = math.pi / 360
DETECTORS = 30
RANGE = 0.2 * math.pi


STEPS = math.floor(math.pi / STEP)
PATH = 'zdjecia'
image = misc.imread(os.path.join(PATH, 'Paski2.jpg'), flatten=1)
R = (len(image) ** 2 + len(image[0]) ** 2) ** 0.5
WIDTH = len(image[0])-1
HEIGHT = len(image)-1

def compute_coordinates(phi):
    x = R * np.cos(phi)
    y = R * np.sin(phi)
    y = int(y + 0.5 * len(image))
    x = int(x + 0.5 * len(image[0]))
    return (y, x)


sinogram = []
for i in range(STEPS):
    middle_angle = i * STEP
    projection = []
    for ray in range(-DETECTORS, DETECTORS, 1):
        shift_angle = ray * RANGE / (2*DETECTORS+1)
        start_point = compute_coordinates(middle_angle + shift_angle)
        end_point = compute_coordinates(middle_angle + math.pi - shift_angle)
        projection.append(bresenhamLine2(start_point, end_point, image))
    sinogram.append(projection)
plt.figure(1)
plt.imshow(tuple(sinogram), interpolation='nearest', cmap='gray')
plt.show()

recoveredImage = [[0 for x in range(WIDTH)] for y in range(HEIGHT)]
for i in range(STEPS):
    middle_angle = i * STEP
    if i%(math.floor(STEPS/4-1) ) == 0:             #progress in 4 steps
        plt.imshow(tuple(recoveredImage), interpolation='nearest', cmap='gray')
        plt.show()
    for ray in range(-DETECTORS, DETECTORS, 1):
        shift_angle = ray * RANGE / (2*DETECTORS+1)
        start_point = compute_coordinates(middle_angle + shift_angle)
        end_point = compute_coordinates(middle_angle + math.pi - shift_angle)
        recoveredImage = backwardBresenham(start_point, end_point, recoveredImage, sinogram[i][ray + DETECTORS])